---
title: 《Neural Network Methods in NLP》笔记
date: 2019-04-08 09:52:00
author: 长腿咚咚咚
toc: true
mathjax: true
top: true
categories: nlp_Research
tags:
	- 《Neural Network Methods in NLP》笔记
---

[TOC]

在刚接触到机器学习的时候，看了周志华老师的《机器学习》，其中的概念和举例对入门机器学习很有帮助，李航老师的《统计学习方法》更是用严谨的定义和详细的公式对机器学习进行了补充。而在理论基础支撑的实践层面，使用scikit-learn库可以对**结构化数据**进行分析、预测等各种各样的操作。

结构化数据比较直观，可是**文本数据**该怎么表示和处理呢？ 《Neural Network Methods in Natural Language Processing》这本书给了答案，这本书是一本非常适合入门自然语言处理的书籍，足够薄，最关键的是有中文版。。。是哈工大车万翔老师团队翻译的，在一定程度上做到了权威。不过有的地方翻译的意思有出入，对照英文版就可以了 

本书可分为四部分。第一部分介绍神经网络的基础。第二部分介绍自然语言数据的处理。第三部分介绍特殊的深度学习结构。第四部分是一些非核心主题，我觉得相比之下，一些会议的Tutorials更值得阅读。

以下是我在阅读过程中的笔记，或者说是我摘录的重点，可以快速重复阅读的那种。



## 1. 引言

- **自然语言三个特性**。离散性（ 语言是符号化和离散的）、组合性(字母形成单词，单词形成短语和句子) 和 稀疏性（以上性质的组合导致了数据稀疏性）
- 有两种主要的神经网络结构，即前馈网络（ feed-forward network）和循环／递归网络(recurrent/ recursive network），它们可以以各种方式组合。

- 循环神经网络 （RNN）是适于序列数据的特殊模型，**循环网络很少被当作独立组件应用**，其能力在于可被当作可训练的组件“喂”给其他网络组件，然后串联地训练它们。例如，循环网络的输出可以“喂”给前馈网络，用于预测一些值 。循环网络被用作一个输入转换器，其被训练用于产生富含信息的表示，前馈网络将在其上进行运算。
- 前馈网络，也叫 多层感知器（ Multi Layer Perceptron , MLP），其输入大小固定，对于变化的输入长度，我们可以忽略元素的顺序。
- **循环网络打破自然语言处理中存在几十年的马尔可夫假设**，设计能依赖整个句子的模型，并在需要的情况下考虑词的顺序，同时不太受由于数据稀疏造成的统计估计问题之苦。
- **语言模型 (language modeling）指的是预测序列中下一个单词的概率**（等价于预测一个序列的概率），是许多自然语言处理应用的核心 。
- **大部分情况下，全连接前馈神经网络 CMLP 能被用来替代线性学习器** 。 这包括二分类或多分类问题，以及更复杂的结构化预测问题 。网络的非线性以及易于整合预训练词嵌入的能力经常带来更高的分类精度



## 2. 学习基础与线性模型

### 2.1 有监督学习和参数化函数

- 假设类 ：搜索所有可能的程序〈或函数〉是非常困难（和极其不明确）的问题，通常把**函数限制在特定的函数簇内**，比如所有的具有d_in个输人、 d_out个输出的线性函数所组成的函数空间，或者所有包含 d个变量的决策树空间 。 **这样的函数簇被称作假设类**.
- 归纳偏置： 通过把搜索限制在假设类之中，我们向学习器中引入了归纳偏置（ inductive bias ）， 当学习器去预测其未遇到过的输入的结果时，会做一些假设。而学习算法中归纳偏置则是这些假设的集合，同时也使得搜索结果的过程更加高效。补充：归纳偏置可以**看作学习算法自身在一个庞大的假设空间中对假设进行选择的启发式或者“价值观”**。即天涯何处无芳草，却为什么偏偏选择你！！！
- 假设类也确定了学习器可以表示什么、不可以表示什么 。学习器的目标是确定参数的值，因此，搜索函数空间的问题被缩减成了搜索参数空间的问题 。
- **线性函数的假设类相当有限，有很多它无法表示的函数**（的确，它只限于线性关系〉。具有隐层的前馈神经网络同样是参数化函数，但构成了一个非常强大的假设类一一它们是通用近似器，可以表示任意的波莱尔可测量函数。
- 线性模型虽然表示能力有限，但它也有几个我们想要的性质 ： 训练简单高效，通常会得到凸优化目标，训练得到的模型也有点可解释性，它们在实践中往往非常有效 。它们也是更强大 的非线性前馈网络的基本模块。



### 2.2 训练集、测试集和验证集

- 关于数据集划分：**留一法——留一交叉验证**：训练 k个函数  ，每次取出一个不同的样例 x作为测试集，剩余样本作为训练集，评价得到的函数 f预测的能力，最后选中一个表现最好的函数。非常浪费计算时间，只会在已标注样例数量 走特别小（小于 100 左右〉的时候使用 。在《统计学习方法》中，被叫做**k折交叉验证**
- **留存集**：划分训练集为两个子集，可以按80% /  20%划分，在较大的子集（训练集）上训练模型，在较小的子集（留存集， held-out set ）上测试模型的准确率。《统计学习方法》中，被叫做**简单交叉验证。**
- 进行划分时要注意一些事情一一通常来说在划分数据前打乱样例，保证一个训练集和留存集之间平衡的样例分布是更好的。有时随机的划分不是一个好的选择：与时间相关的训练集如果进行随机划分就会有影响。
- **三路划分：**留存集（测试集）进行误差估计不能代表新实例的效果，不知道最终的分类器的设置在总体上是好的，还是仅仅在留存集中的特定样例上是好的 。已被接受的方法是使用一种把数据划分为训练集、验证集（也叫作开发集）和测试集的三路划分方法 。 这会给你两个留存集： 一个是验证集，一个是测试集 。 所有的实验、调参 、误差分析和模型选择都应该在验证集上进行 。 然后，最终模型在测试集上的一次简单运行将会给出它在未见实例上的期望质量的一个好的估计 。



### 2.3 线性模型

- 非线性可分的情况下（不能使用一条直线或一个线性超平面将数据点分开), 解决方法**要么是转换到更高维的空间**（加入更多的特征），要么是**转换到更丰富的假设类**，或者**允许一些误分类**存在。
- **特征表示**：在大多数情况下这些数据点不会以特征列表的形式直接提供给我们，而是作为真实世界中的对象 。例如，我们被给予一系列公寓来分类。然后，我们需要做有意识的决定，手动选择我们认为对于分类任务有用的可测量属性 。就特征集合做出决定之后，我们创造一个特征抽取（ feature extraction）函数，它把真实世界的对象（公寓）映射成一个可测量量度（价格和大小）的向量，该向量可以作为我们模型的输入。
- **线性模型设计的一个核心部分是特征函数的设计**（所谓的**特征工程** ）。深度学习的开创性之一是，它通过让模型设计者指定一个小的核心、基本或者自然的特征集，让可训练的神经网络结构将它们组合成更有意义的、更高层次的特征或者表示，从而大大地简化了特征工程的过程 。
- **sign和sigmoid**：将原本值域为负无穷到正无穷的结果，使用sign函数将结果映射到[-1,+1]可以得到二分类的结果，使用sigmoid 函数将结果映射到 [0,1]范围之内，即可计算决策的置信度或者分类器分配这个类别的概率。



### 2.6 对数线性多分类

- 多分类问题：不同于二分类的求得能将其分开的超平面的一个模型，n分类需要构建n个模型，每个模型预测一种结果的可能，最终的结果取决于最高分的模型所属于的结果。

- **BOW( Bag-of-words）**表示包含文档中所有单词的不考虑次序的信息 。一个独热表示可以被认为是一个单一单词的词袋 。**CBOW(Continuous Bag Of Words) 连续单词词袋**，表示可以通过求单词表示向量和或者通过将一个单词词袋向量乘以一个每一行对应于一个稠密单词表示的矩阵(嵌入矩阵 embedd ingmatricy)来得到。     1="A B C"     2="A D"     BOW=[A B C D]  CBOW=[A B C A D ]  

- **Sigmoid和Softmax这两个概念有什么区别和联系**
  - sigmoid把一个值映射到0-1之间，常常使用于二分类，把线性预测转变为一个概率估计，从而得到一个**对数线性模型**。
  
  ![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083751895.png)
  
  ![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083760411.png)
  
  - softmax。多分类情况中是把分数向量通过一个softmax，它将一个K维的任意实数向量映射成另一个K维的实数向量，其中向量中的每个元素取值都介于(0,1)之间并且和为1。 



### 2.7 训练和最优化

- 关于损失函数：在大多数情况下，**推荐使用常见的损失函数而不是自行定义**。
- hinge （二分类）、hinge （ 多分类 ）、对数 （log ） 损失、二元交叉熵--逻辑斯蒂 (logistic）损失、分类交叉熵 （ categorical cross-entropy） 损失（* ?）、等级损失
- **正则化方法**：L1、L2、dropout
- 随机梯度下降和基于minibatch的随机梯度下降：一个样本和一小批样本的区别



## 3. 从线性模型到多层感知器

- 线性模型的局限性（只限于线性关系）：异或(XOR)函数,没有一条直线能够分割这两个类别。

<img src="%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083791339.png" alt="img" style="zoom: 33%;" />![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083795864.png)

<img src="%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083791339.png" alt="img" style="zoom: 33%;" />![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083795864.png)

- **非线性输入转换**：¢(x1,x2)＝［x1 * x2, x1 + x2］函数 ¢ 将数据映射为适合线性分类的表示。该解决方案有一个明显的问题，我们需要人工 。定义函数¢，此过程需要依赖特定的数据集 ，并且需要大量人类的直觉。
- **核方法**：通过定义一些通用的映射来解决上述问题。多项式映射， ¢(x)=(x)^d。d=2时，¢(x1,x2)=(x1x1,x1x2,x2x1,x2x2).对所有的变量进行两两组合.
- **可训练的映射函数**：映射函数可以采用参数化的线性模型形式，接一个作用于每一个输出维度上的非线性激活函数 g :    y= ¢(x)(W+b)， ¢(x)= g(xW'+b')。自行定义g(x)和训练W‘、b’得到一组参数，即可获得一个映射。



## 4. 前馈神经网络

- 完全连接层或仿射层：每个神经元连接到下一层中的所有神经元
- 最简单的神经网络称作感知器，是一个简单的线性模型 ：NN(x)=xW+b.
- 由线性变换产生的向量称为层 。 最外层的线性变换产生输出层，其他线性变换产生隐层 。 非线性激活操作接在每个隐层后面。由线性变换产生的层通常被称为完全连接的或仿射的。
- **MLPl 是指带有单一隐层的多层感知机**
- 线性变换的维度计算：对一个输入维数 d_in ， 输出维数 d_out 的全连接层，有 l(x) =xW+ b ，其中 x 、 W、 b 的维数分别为 1 × d_in 、 d_in × d_out 、1× d_out。当输入的向量为行向量

![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083817021.png)

- **常见的非线性函数**:根据经验来看， ReLU 和 tanh 单元表现良好，显著地超过了 sigmoid
  - sigmoid：σ(x)= l / (1 + e^(-x) )  逻辑斯蒂函数，近来被认为不适合用在神经网络的内层
  - tanh：tanh(x)=(e^(2x)-1) / (e^(2x)+1)    值域 [-1,1]
  - hard tanh=    -1(x<-1)    1(x>1)    x(其他)
  - 修正线性单元（ ReLU)   ：max(0, x)  在很多任务中都表现优异，尤其是使用dropout正则化的时候
- 称为权重衰减的 L2 正则化在许多情况下能有效地实现良好的泛化性能。
- dropout也是一种防止神经网络过度拟合训 练数据的有效技术，旨在防止网络学习依赖于特定权重。在对每个训练样本进行随机梯度训练时，它随机丢弃网络(或特定层)中的一半神经元 。
- dropout细节：考虑具有两个隐层 (MLP2 )的多层感知器：
  - 从x到y的过程：NN(x)=y;    h^1=g^1(xW^1+b^1);   h^2=g^2(h^1 * W^2+b^2);  y=h^2 *W^3;
  - 当在 MLP2 中使用dropout时，我们在每轮训练中**随机地设置 h^1 和 h^2 的部分值为0,** 通过将h^1乘一个掩码向量(元素值为0或1)，将乘得的结果代替原隐层h^1，传入下一层。
- 相似和距离层：希望基于两向量计算一个标量值，反映出两向量间的相似性、兼容性或距离 
  - 点积：两向量的同index数值相乘求和。
  - 欧式距离：两向量的同index数值的差的平方和。这是一个距离度量而不是相似度, 在这里, 小值表示相似，较大值表示不相似
  - **可训练形式**：有时希望使用一个参数化函数，通过关注向量的特定维度，来进行训练以产生所需的相似度。常见的可训练相似度函数是**双线性形式（ bilinear form)** sim(u,v)=uWv

**五、神经网络训练**

- 计算图：一个有向无环图(DAG)，其中结点对应于数学运算或者变量，边对应于结点间计算值的流 。计算(a * b + 1) * (a * b +2): 

![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083655556.png)

- a * b 的计算是共享的 。有一个限制条件，就是计算图是连通的。

<img src="%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083827624.png" alt="img" style="zoom: 50%;" />

- **实践经验：**
  - 优化算法：SGD收敛速度慢、Adam有效
  - 初始化：减少陷入局部最小的可能
  - 随机重启：多次训练，每次都随机初始化，选取验证集最好的一个
  - 梯度消失和梯度爆炸、饱和神经元与死神经元
  - 训练样本的随机打乱
  - 学习率的调整



## 6. 文本特征构造

### 6.1 NLP 分类问题中的拓扑结构

词、文本、成对文本、上下文中的词、词之间的关系

### 6.2 NLP 问题中的特征

特征通常表现为标量indicator和可数count两种形式：条件是否出现，事件出现频率

#### 6.2.1直接观测特征

- **单独词特征**
  - 词元（booking, booked, books）和词干（book）
  - 词典资源（和其他词语连接起来或者提供额外的信息）例如wordNet
  - 分布信息（哪些词和当前词是类似的）
- **文本特征：字符和词再文本中的数量和次序**
  - 词袋（bag-of-words）：表示包含文档中所有单词的不考虑次序的信息 。词袋中各个词在文本中出现的数量，作为特征。
  - 权重：TF-IDF（TF * IDF，词频*逆向文件频率）：某词对于一个语料库中的其中一份文本的重要程度。某词在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。
  - n元组
- **上下文词特征**
  - 词在句子和文本中，其在句子的位置、围绕它的词和字符都可以作为特征。越近信息量越大
  - 窗口：{ word-2=brown, word-l=fox, word+l=over, word+2=the ｝

#### 6.2.2 可推断的语言学特征

- 自然语言中的句子除了是词语的线性排序外还是有结构的。这种结构遵循复杂的不易于直接观察到的规律，这些规律被归类为语法。文本的语言学特性并不能够从词在句子中或其顺序的外在表现直接观察到，它们能够以不同程度的准确率从文本句子中推断出来。
- 语言学标注：
  - 成分树（ constituency tree），或短语结构树。
  - 依存树（ dependency tree），除了句子的中心词（通常是动词），每个句子中的词都被另一个词所引领，每个词都是另一个词的修饰。
  - 词性标签、句法角色、篇章关系、回指等概念是基于语言学理论的



6.2.3 核心特征和组合特征   多用组合特征

6.2.4 n 元组特征    在给定的长度下由连续的词序列组成，比单独的词富含更多信息

6.2.5 分布特征



## 7. NLP特征的案例分析

- 7.1 文本分类：语言识别：字母级文法词袋（字母级别的特征）
- 7.2 文本分类：主题分类：字母级别特征不合适，词为基本单位，例如二元文法词袋等
- 7.3 文本分类：作者归属：避开内容词，侧重于文体属性（可以表现出来的特征list: 功能词与代词词袋，词性词袋，词性的n元文法词袋 ）
- 7.4 上下文中的单词：词性标注：内部线索（单词、单词的字母前缀与后缀，是否大写、是否包含连字符、是否数字）+外部线索（上下文的单词的内部线索）
- 7.5 上下文中的单词：命名实体识别：是一个序列分割任务，但通常被建模为序列标注任务，类似于词性标注。特征类似于词性标注，内部线索+外部线索
- 7.6 上下文中单词的语言特征：介词词义消歧。特征：词本身（单词、词元、词性、前后缀、词簇or分布式表示）+信息量较大的上下文（固定窗口上下文可能不富含太多信息，可用启发式规则，举例：左边第一个动词右边第一个名词形成三元组特征、依存分析器-好用），也可以用外部资源（知识库wordNet）
- 7.7 上下文中单词的关系：弧分解分析（依存分析任务）：给定长度为n的句子，有n*n个词关系，为每个词关系分配分数，得到一个最大化总体分数的有效的树。可构建特征：头词和修饰词的字面形式、词性、距离、方向、两者之间的词or词性等等。



## 8. 从文本特征到输入

8.1 编码分类特征：独热编码(one-hot)和稠密嵌入向量

稠密表示的主要益处是具有很强的泛化能力 (Page95)

**8.2 组合稠密向量（个人认为这章的特征很实用）**

每个特征对应一个稠密向量，需要用某种方式将不同的向量组合起来，主要有拼接、相加（或者平均）和同时使用拼接与相加 。

- **基于窗口的特征**

​       位置i为中心词时，需要编码位置在 i-2、i-1、i+1、i+2 上的词。不关心窗口内词的位置：**词向量求和**a+b+c+d；关心：**词向量拼接**[a:b:c:d]；不关心顺序但是关心距离：**加权求和**0.5a+b+c+0.5d（距离越远权重越小）；不关心距离但是关心前后：**拼接和相加组合**，[a+b:c+d] 

​       显式拼接（[x: y: z]W＋b)，**仿射变换** （ xU+ yV+zW+ b ）,如果后者参数矩阵互不相同，则两种方式是等价的。

- **可变特征数目：连续词袋CBOW**

 用于使用固定维度的向量表示任意数量的特征。

CBOW 和传统的不考虑顺序信息的词袋表示非常相似，通过相加或者平均的方式组合特征的嵌入向量。or 加权CBOW，为不同向量赋予权重，权重可以是TF-IDF

**8.3 独热和稠密向量间的关系**

​       在训练神经网络时，使用稀疏独热向量作为输入，意味着使网络的第一层从训练数据中学习特征的稠密嵌入向量。当遇到多层前馈神经网络时，稠密和稀疏输入之间的区别会比起初看起来的更小。

独热向量，通过与一个嵌入矩阵E的乘法操作，得到稠密向量。这个矩阵E的维度是V * d，d是每个词的表示维度，V是单词数表示有V行，每一行代表一个独热向量的对应的稠密向量。这样的**嵌入层/查找层**，即可将独热向量映射为稠密向量。

**8.4 杂项**

- **距离与位置特征**

​        一个句子中两个词的线性距离可能作为一个提供信息的特征。在传统 NLP 情景下，通常将距离分配到若干组（如 1, 2, 3, 4, 5-10, 10+）中，并且为每一组赋予一个 one hot向量。在神经网络框架中，输入并没有直接分配一个距离数值的入口，而是将传统分组的one hot向量映射到一个类似词嵌入的d(6)维向量，这些距离嵌入向量作为网络参数进行训练（个人理解，欢迎指正，Page104有例子）

- **一些处理数据的tips**
  - **补齐**
    当使用拼接方法时，可以用零向量进行填充，这对于某些问题来说可能只是次优解，也许知道左侧没有修饰成分是有益的。推荐的做法是添加一个特殊符号（**补齐符号**〉到嵌入词表中，并且在上述情况中使用相应的补齐向量。根据要处理的问题不同，在不同情况下可能会使用不同的补齐向量 （比如左侧修饰缺失向量与右侧修饰缺失向量不同）。 这样的补齐对预测的准确性是很重要的，并且非常常用 。很多论文没提，只有源码才会看到。
  - **未登录词**
    没有对应词嵌入向量时，保留一个特殊符号 UNK 表示未知记号来应对这种情况。同样对于不同的同表可能会使用不同的未知符号，但不管怎样，都不建议共享补齐和未登录向量，因为它们代表两种不同的情况 
  - 词签名
    处理未登录词的另一种技术是将词的形式回退到词签名 。使用 UNK 符号表示未登录词是将**所有未登陆词回退到同样的签名**，但是根据要解决的问题的不同，可能使用更加细粒度的策略，比如用 一ing  符号代替以 ing 结尾的未登录词，等等。
  - 词丢弃
    在训练集中抽取特征时，用未登录符号随机替换单词。基于词频
  - 使用词丢弃进行正则化

- 特征组合
  特征设计者不仅需要人工指定感兴趣的核心特征，同时要指定特征间的交互。（如除引人“词为 X”，“词性为 Y”的特征外，还有组合特征表示“词为 X 并且词性为 Y”）

- 向量共享
  构建输入时，是否需要对特征用两个不同向量表示。经验问题。

- 维度  ——每个特征分配的维度。速度和准确度取得一个良好平衡。

- 网络的输出：k分类问题输出一个k维向量，每一维表示类别强度。

  

8.5  例子：词性标注     词序列提取特征的细节

8.6  例子：弧分解分析    包含两个词和中间文本的弧的特征提取细节



## 9. 语言模型

9.1 语言模型任务

- 给某单词在一个词序列之后出现的可能性分配概率；给句子分配概率(一系列的词预测)

- **马尔可夫假设**：规定未来的状态和现在给定的状态是无关的。形式上， 一个走阶马尔可夫假设假设序列中下一个词**只依赖**于其前k个词。

  

9.2 语言模型评估：困惑度

- 以应用为中心的度量方法通过在**更高级别的任务中的性能**来进行评价 。 例如， 当将翻译系统中的语言模型组件从 A 替换为 B 后,测量翻译质量提高的程度 。
- 一个更直观的评估语言模型的方法是对于未见的句子使用**困惑度**

是一种信息论测度，用来测量一个概率模型预测样本的好坏，困惑度越低越好 。给定一个包含n个词的文本语料和一个基于词语历史的用于为词语分配概率的语言模型函数 LM ,LM 在这个语料的困惑度最低，语言模型越好。



9.3 语言模型的传统方法

- 语言模型的传统方法假设 h 阶马尔可夫性质
- 预测从未在语料中观察到的序列，会出现0概率，造成极大困惑度，这是个很糟糕的情况。一种避免 0 概率事件的方法是使用平滑技术，确保为每个可能的情况都分配一个概率（可能非常小）。

add-α： 它假设每个事件除了语料中观测的情况外，至少还发生 α 次

退避(back off)：如果没有观测到 h 元文法，那么就基于（k-1) 元文法计算一个估计值

- 传统语言模型的限制：平滑技术错综复杂而且需要回退到低阶；将基于最大似然估计的语言模型应用于一个规模更大的 n 元文法是一个固有的问题；基于最大似然估计的语言模型缺乏对上下文的泛化。



9.4 **神经语言模型**

- 非线性神经网络语言模型可以解决一些传统语言模型中的问题：它可以在增加上下文规模的同时参数仅呈线性增长，缓解了手工设计退避规则的需要，支持不同上下文的泛化性能 。
- 介绍：神经网络的输入是k元文法，输出是下一个词的概率分布。输入的词经过词嵌入后，被传给一个拥有一个或多个隐层的多层感知机（MLP）
- 训练、内存与计算效率、大规模输出空间（层次化softmax--构建huffman树、自归一化方法--没搞懂=_=）、期望特性、局限



9.5 使用语言模型进行生成

9.6 副产品：词的表示



## 10. 预训练的词表示

词嵌入一一将每个特征表示为低维空间中的向量。这些向量来自哪里？本章对常见方法进行了调研

### 10.1 随机初始化

当有足够的有监督训练数据可用时－，可以将特征嵌入看作与其他模型参数相同 ： 将词嵌入向量初始化为随机值，使用网络训练过程将它们调整为“好”的 向量 。

### 10.2 有监督的特定任务的预训练

### 10.3 无监督的预训练

训练词向量的技术本质上是有监督学习的技术，不是对我们关心的任务进行监督，而是**从原始文本创建几乎无限数量的有监督训练实例**，并希望我们创建的任务将匹配（或足够接近）我们关心的最终任务。

使用与训练的词嵌入，第一个选择是关于预处理，第二个选择是在这个任务上对预训练的向量进行微调 。



### 10.4 词嵌入算法（这章建议看英文原版参考）

神经网络社区倾向于从**分布式表示 distributed representations**的角度思考 。自然语言处理社区倾向于从**分布语义 distributional semantics**的角度思考

#### 10.4.1 分布假设和词表示 Distributional hypothesis and word prepesentations

explore the distributional approach to word representation **词的分布表示**
关于语言和词义的分布式假设表明，在相同上下文中出现的词倾向于具有相似的含义。

* **词－上下文矩阵** -- i行j列，表示 i 个单词 * j 维度。每列表示词出现的语言学上下文。
  **相似性度量**，词被表示为向量就可以通过计算向量相似度来计算词的相似度。 
* 余弦相似度(向量之间角度的余弦)、广义 Jaccard 相似度
* 词——上下文权重和**点互信息(PMI)**
  在求得词上下文矩阵时，其通常基于来自大规模语料库的计数。
  PMI (w, c）通过计算词和上下文的联合概率（它们在一起的频率）与它们的边界概率（它们单独出现的频率）之间的比率的对数来测量词 w 和上下文 c 之间的关联 。减少过高的权重带来的不好的影响。（例如：the cat 和 a cat 可 以获得高于 cute cat 和 small cat 的分数，即使后者的信息量更多）

- 通过矩阵因式分解进行降维

  将词表示为其出现的上下文的显式集合的潜在障碍是数据稀疏性。显式词向量具有非常高的维度。通过使用诸如奇异值分解(SVD)的降维技术来考虑数据的低阶表示，可以缓解这两个问题。



#### 10.4.2 从神经语言模型到分布式表示 From neural language models to distributed

explore the distributed approaches.   **词的分布式表示**

与词分布表示——基于计数的方法相比，神经网络社区主张使用分布式来表示词义。

* 考虑语言建模网络：通过词嵌入矩阵和上下文矩阵确定给定上下文的不同词的概率，为上下文的k元组生成一个概率，上下文矩阵和词嵌入矩阵就是分布式的词表示：训练过程决定了词嵌入的理想值。

- Collobert 和 Weston
- word2vec：CBOW、Skip-gram(觉得这章讲的有点过于细了，有点乱)  
  word2Vec 模型训练带来了两个词嵌入矩阵 ，分别代表同和上下文矩阵 。 上下文嵌入会在训练后被丢弃，但保留了词嵌入。

#### 10.4.3 词语联系

分布式“基于计数”的方法和分布式“神经”方法都是基于分布假设，尝试基于它们出现的上下文之间的相似性来捕获词之间的相似性。这两个方法之间的关系 比乍看之下更深。

#### 10.4.4 其他算法    NCE   Glove



10.5 上下文的选择

窗口方法(CBOW)、句子段落或文档(Skip-gram)、句法窗口（使用依存句法解析器自动解析文本，并将词的上下文视为解析树中邻近的词以及与之相关的句法关系 ）、多语种（使用多语种、基于翻译的上下文，例如与其对齐的外语单词）、基于字符级别和子词的表示（从一个词的组成字符中生成向量表示）

10. 6 处理多字单元和字变形

- 问题：1. 对多字分配单一变量、2. 形态学变形使有相同潜在概念的词不同。
- 可以通过对文本进行确定性预处理从而达到合理的程度，以至于更好地适应所想要的词语定义。可以生成多符号串词条列表，并用文本替换单个实体（即用 New_ York 替换 New York 的出现）
- 在变形的情况下，对语料预处理，包括对部分或全部词汇抽取词干，对词干嵌入而不是对其变形形式嵌入。

10. 7 分布式方法的限制

相似性的定义、害群之马（词的琐碎属性）、反义词（反而会出现在相似的情境）、语料库偏好、语境缺乏



## 11. 使用词嵌入

本章讨论一部分词向量的用途。

11. 1 词向量的获取

- word2Vec    可获取的单独的二进制文件、GenSim的python包、允许使用任意上下文信息的改进版二进制 Word2Vec、斯坦福发布的GloVe 模型的有效实现等等……

11. 2 词的相似度（利用向量之间的相似度函数计算两个词的相似度：**余弦相似度）**11.3 词聚类、11 .4 寻找相似词、11. 5 同中选异、11. 6 短文档相似度、11. 7 词的类比（king - man - woman = queen）、11. 8 （对词向量的）改装和映射、11. 9 实用性和陷阱（当使用现成的词向量时，最好使用与源语料相同的切分词项的方法和文本规范化方法。仍然建议不要这样像黑盒方法一样盲目地下载和使用这些资源）



## 12. 案例分析：一种用于句子意义推理的前馈结构

12. 1 自然语言推理与 SNLI 数据集

- 文本蕴含任务：两文本的关系有蕴含（前者推断出后者）、矛盾（不可同时为真）、中立
- SNLI 是包括 57 万人类手写的句子对，每对都由人工标注为蕴含、矛盾和中立。

12. 2 文本相似网络

- 计算句子对a、b的相似度
  - 依次计算a中某词与句子b中所有词的相似度，得到该词的对齐向量，softmax处理
  - 每个对齐向量都有对应的权重
  - 向量结果加和，传递到一个MLP分类器中，用于预测句子关系。
  - 然后训练
- 网络的目标是为了找到有助于蕴含的关键词。最终，决策网络从词对中聚合数据，并且据此提出决策 。 推断分为三个阶段：第一阶段根据相似度对齐找到较弱的局部证据，第二阶段查看带权重的多个词单元并加入方向性，第三阶段将所有局部证据整合成全局决策 。



第三部分、特殊的结构（这个介绍不错，建议详细看）

## 13. n元语法探测器：卷积神经网络

13. 1 基础卷积＋池化

- 13.1.1 文本上的一维卷积
  - 卷积操作：滑动窗口向量与滤波器的内积，其后通常会使用一个非线性激活函数。
  - **宽卷积与窄卷积**：窄卷积：窗口大小k，句子长度n，共有n-k+1个序列开始位置；             宽卷积：对句子每端填充k-1个填充词，n+k-1个序列开始位置(书写错了？)
  - 两种卷积方式：实质上等价，不同的是卷积核矩阵维度为 k*d*l，和 l 个k*d维的卷积核
  - 信道：多信道(图像数据)，通常对每个信道使用不同的滤波器集合，文本也可能多信道
- 13.1.2 向量池化
  - 最大池化：获取整个窗口位置中最显著的信息
  - 平均池化：一种理解是对句子中连续词袋 (CBOW) 而不是词进行卷积得到的表示。
  - k-max：每一维度保留前k个，同时保留文本中的顺序。保留了特征间的序关系，但对具			体位置不敏感
  - 动态池化：卷积后得到的向量进行分组，每组分别池化，结果拼接。即分区域池化(例如关系抽取中两个词分割开的三块文本区域）
- 13.1.3 变体
  - 平行的使用多个卷积层（窗口大小不等，捕获序列中不同长度的 n 元语法）



13. 2 其他选择：特征哈希

用于文本的CNN计算开销大。直接使用 n元语法的词嵌入，然后池化得到连续词袋 n 元语法表示。使用特征哈希，n元语法通过哈希函数指派给N行词嵌入矩阵的一行，映射到[1，N]，使用对应行作为词嵌入。



13. 3 层次化卷积

- 一个窗口大小为k的卷积层学习识别输入中具有指示性的k元语法。这种方法可以扩展成层次化卷积层，卷积序列逐层相连。得到的向量捕获了句子中更有效的窗口(“感受野”)
- 步长、膨胀和池化

膨胀的方法：步长为k-1；步长为1但是每层间使用局部池化缩短序列长度

- 参数捆绑和跨层连接

层次化卷积结构的一种变形是进行参数捆绑，对于所有参数层使用相同的参数集合 U, b 。



## 14. 循环神经网络：序列和栈建模

处理序列：前馈网络(CBOW忽略序关系)、CNN(局限于局部)、RNN(**序列输入翻译成定长向量**)

14. 1 RNN 抽象描述：R、O决定网络类型

<img src="%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083912624.png" alt="img" style="zoom:67%;" />

14. 2 RNN 的训练

展开形式的RNN就是一个深度神经网络、不同部分在计算过程中  **参数共享**

为了训练一个RNN，需要对输入序列构建一个展开的计算图，为展开的图添加损失节点，反向传播更新参数

14. 3 RNN 常见使用模式

- 接收器：监督信号仅置于最后的输出向量 y_n 上。观测最后一个状态，然后决策一个输出。
- 编码器：仅使用最后的输出向量y_n，把 y_n 与 输入相关的其他特征 进行后续任务。
- 传感器：对于每一个读取的输入产生一个输出（序列标注任务）

14. 4 双向 RNN

- 动机：计算第i个单词，计算过程基于历史信息，然而后继的单词对于预测同样有效。
- 输出变动：第i个位置的输出基于**前向后向两个输出向量的拼接**，即同时考虑历史和未来的信息。
- 输出之后：拼接得到的输出向量，**在接下来可以直接用来进行预测，或作为更复杂网络输入的一部分**
- Bi-RNN 在一个输人向量对应一个输出向量的标注任务中非常有效 

14. 5 堆叠 RNN

- **Deep RNN:**RNN逐层堆叠成网格，第n个RNN的输入是其下方RNN的输出。
- 在某些任务的观测经验中看， deep RNN 的确比浅层的表现更好 

14. 6 用于表示梭的 RNN

一些语言处理算法，需要对栈进行特征提取，RNN可以用来对整个栈的固定大小的向量编码。

14. 7 文献阅读的注意事项

从学术论文的描述中推测出准确的模型形式往往是很有挑战性的 。

- RNN输入是独热向量还是词嵌入
- 输入序列有没有对开始字符和结束字符填充处理
- 一些论文假定RNN输出送入的softmax层是RNN自身的一部分
- 多层RNN中，状态向量可以是顶层输出，也可以是所有层状态向量的拼接。
- 在编码器－解码器框架下，作为解码器条件输入的编码器的输出可以有不同的诠释？



## 15. 实际的循环神经网络结构

15. 1 作为 RNN 的 CBOW

选择加法函数：RNN内部是一个简单的加法：

![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083954371.png)

本质上是一个连续的词袋模型，输出是输入之和。

**15. 2 简单 RNN  ——**  S-RNN

 	简单RNN是对前一个状态s_(i-1)和输入x_i 分别线性变换，结果相加，连同同一个偏置项，加一个激活函数tanh或ReLU。输出与隐藏状态相同。

![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083962745.png)

S-RNN仅仅比 CBOW 稍微复杂了一点，主要不同之处在于非线性的激活函数 g 。然而，这个不同之处却至关重要，因为加入线性变换后跟随非线性变换的机制使得网络结构对于序列顺序敏感 。

**15. 3 门结构**

**LSTM要解决的问题：**梯度消失，使得 S-RNN 很难有效地训练 。误差信号（梯度）在反向传播过程中到达序列的后面部分时迅速减少，以至于无法到达先前的输入信号的位置，这导致 S-RNN 难以捕捉到长距离依赖信息。

**LSTM的考虑：**考虑S-RNN 其中的状态代表一个有限的记忆 。每一个单元都会读人一个输入x_i以及当前的记忆s_(i-1) ，对它们进行某种操作，并将结果写人记忆得到新的记忆状态 s_(i+1) 。从这种方式看来，S-RNN 的一个明显的问题在于记忆的获取是不受控制的。在每一步的计算过程中，整个记忆状态都被读入，并且整个记忆状态也被改写。

**改进：**提出一种更加受控的记忆读写方式。由当前记忆状态和输入共同控制的门向量，来控制记忆状态的读写。

- **15. 3. 1 长短期记忆网络（下面有PPT做的图）**

![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083970476.png)

- - 时刻 j 的状态由两个向量组成：**记忆组件c_ j 和 隐藏状态组件h_ j**
  - **输入门 i、遗忘门 f、输出门 o**: 门的值由当前输入x_ j 和前一个状态 h_(j-1) 加一个sigmoid决定

1. **遗忘门**控制先前的记忆c_(j-1)，记忆c_ j 更新，
2. **产生更新候选项z：** 由当前输入x_j 和前一个状态h_(j-1) 加一个tanh得到
3. **输入门**控制更新候选项，记忆c_ j 更新
4. **记忆h_ j (y_j的输出) 生成**，c_j 通过tanh非线性激活函数，并受输出门控制

![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083979477.png)



- - 实践的考虑：在训练 LSTM 网络的时候，强烈建议将遗忘门的偏置项设置为接近 1 的值 

- **15.3.2 门限循环单元**

GRU是一种LSTM的替代方案。GRU 也基于门机制，但是总体上使用了更少的门并且网络不再额外给出记忆状态。

![img](%E3%80%8ANeural%20Network%20Methods%20in%20NLP%E3%80%8B%E7%AC%94%E8%AE%B0/clipboard-1579083866812.png)



- - 门 r 合并遗忘们和输入门，控制前一个状态s_(j-1)并计算一个新提出的 s_j~ 
  - 更新的状态s_j 由前一个状态和s_j~ 插值决定，比例通过门控z控制。



15. 4 其他变体

- 非门结构的改进
- 在可微门结构之外



15. 5 应用到 RNN 的丢弃(dropout)机制

在 RNN 中应用丢弃（ dropout）机制需要一定的技巧，因为在不同的时间点丢弃不同的维度会损害 RNN 有效携带信息的能力。

Gal 的变分 RNN 丢弃方法是目前应用于 RNN 中效果最好的丢弃机制。



## 16. 通过循环网络建模

16. 1 **接收器**（14. 3 有RNN 常见使用模式）

接收器：监督信号仅置于最后的输出向量 y_n 上。观测最后一个状态，然后决策一个输出。读入一个序列，最后产生一个二值或者多分类的结果。

- 16. 1. 1 情感分类器

- - 句子级情感分类任务中，给定一个句子，将这个句子分成两类中的一个 ： 积极的或消极的。这个任务通过使用 RNN 接收器能够很直接地进行建模： RNN 读人序列化后的词语 。RNN 的最终状态送人一个 MLP ，这个 MLP 的输出层是一个二输出的 softmax 层 。
  - 文本级的情感分类。**层次化结构的方法**：每个句子通过门结构的RNN编码得到一个向量，然后将向量集合送入第二个门结构的RNN中，得到最终的向量，套上MLP和softmax用来预测。

- 16. 1. 2 主谓一致语法检查

- - 英语句子必须要遵守“现在时态谓语动词的单复数必须与动词的主语一致”的规则
  - 模型直接作为一种接收器被训练。这是一项困难的任务，只有非常间接的监督：监督信号不包括任何找到语法信息的线索 。
  - RNN 处理学习任务表现非常好，成功解决了测试集中的绝大多数句子

16.2 **作为特征提取器的 RNN**

RNN 的一个最主要的应用场景就是作为灵活可训练的特征提取器，在处理序列问题时能够替代传统的特征提取通道 。 特别地， RNN 是基于窗口的特征提取器的良好替代者 。

- 16. 2. 1 **词性标注**

- - n个词语的句子，使用特征提取函数转换为输入向量，输入到双层RNN中，产生的输出向量被送入MLP中，用于从可能的 h 个标签中预测这个词语的标签 。
  - 通过训练程序，双向 RNN 将着重于学习序列中 预测词语标签 所需要的那些信息 ，并将其编码在输出向量中 
  - 词语转换成输入向量：可以通过使用一个词嵌入矩阵，也可以通过字符级的 RNN 将词语转化为输入，使用字符级的卷积和池化神经网络来表示词语，

- 16. 2. 2 **RNN-CNN 文本分类**

- - 与标注任务相同的方式，将向量送入逐个读入单词的字符级RNN 或逐个读入单词的卷积一池化层中得到结果
  - 或在字符上应用一个层次化卷积一池化网络，得到更短的向量序列，把结果的向量序列送入RNN 及分类层中

- 16. 2. 3 **弧分解依存句法分析**

- - 输入词语、词性标签和对应的特征向量，投入到RNN中，得到每个词语的编码。将这些编码进行两两拼接送入MLP中，得到一个核心词-修饰词 候选对的打分。
  - 如果一个任务对词语顺序或者句子结构敏感，并且这个任务使用词语作为特征，那么这个任务中的**词语**就能够**被使用词语自身训练的双向 LSTM输出的词向量代替** 。



**十七、条件生成**

17. 1 RNN 生成器

使用 RNN 转换器结构进行语言建模的一个特殊例子：**序列生成**。i 时刻的输出作为i+1时刻输入。

生成器的训练：将其当做**转换器**训练。长度为n的句子，生成具有n+1个输入和n+1个输出的RNN转换器，其中第一个输入是句首符，最后一个输出是句尾符。

局限性：不能更好的处理与黄金序列（观测序列）之间的偏差。在训练时，生成器使用实际词作为每一时刻的输入，而不是前一时刻的预测结果。

**17.2 条件生成（编码器－解码器）**

RNN 转换器的能力直到应用于条件生成的框架中才真正地显现出来 。

条件生成的框架中，下一个词项的生成依赖于己生成的词项以及一个额外的条件上下文 c，几乎任何我们能够获得并且认为有用的数据都可以被编码至上下文c

- 17. 2. 1 序列到序列模型

上下文 c 可以有很多种形式。一种方法是c本身就是一个序列，最常见的是一个文本片段。这种方式下产生了**序列到序列（ sequence to sequence）条件生成框架**，也被称为**编码器一解码器框架**。

给定一个长度n的源序列，生成一个长度m的输出序列。**通过一个编码函数(通常是RNN)将源句子编码，再使用一个条件生成器（解码器）生成输出序列。**

编码器将源句子抽象表示为向量 c，作为解码器的 RNN 则根据当前已预测出的词以及编码后的源句子 c 来预测目标词序列。

用于编码器与解码器的 RNN 是**联合训练**的 。 监督信息只出现在解码器 RNN 端，但是梯度能够沿着网络连接反向传播至编码器 RNN 中

- 17.2.2 应用

- - 机器翻译
  - 邮件自动回复
  - 形态屈折 -- 输入基本词和期望的形态变化需求，输出该词的曲折形式
  - 几乎所有任务都可以用编码-生成的方法建模，但也许存在更适合此任务的结构

- \17. 2.3 其他条件上下文

条件上下文向量可以是基于单个词，或一种连续词袋 CCBOW）的编码，也可以由 一个卷积网络生成，或基于一些其他的复杂计算 。甚至不一定基于文本(对话任务用户的信息)



17.3 无监督的句子相似性

- 为句子学习向量表示，将相似的句子编码为相近的向量。
- 大部分方法是基于序列到序列框架的：首先训练一个 RNN 编码器来产生上下文向量表示 c，该向量将用于一个 RNN 解码器来完成某个任务 。
- 作为解码器的 RNN 将被丢弃，而编码器则用来生成句子表示 c，最终得到的句子间相似度函数将严重依赖于训练解码器所完成的任务 。
- 这些任务可以是：自动编码、机器翻译、skip-thought、句法相似度



**17.4 结合注意力机制的条件生成**

- 编码器-解码器结构**强制编码器中包含生成时所需要的全部信息**，要求生成器中从该定长向量中提取出所有信息。  增加一个注意力机制，可以充分改进。

- 结合注意力机制的**编码器-解码器结构预测过程**：

- - 编码器对长度为n的输入序列编码，产生n个向量。
  - 预测第j+1个词项时，注意力由前 j 个编码器输出的向量和前 j 个词项决定
  - 解码器第j+1个状态，  由注意力、前 j 个词项、第 j 个状态决定
  - 由解码器的最终状态，得到第j+1个词项

- **注意力函数**是一个可训练、参数化的函数。

- - 注意力权重向量由解码器的第 j 个输出、编码器的每个向量，+MLP，决定
  - 再使用 softmax 函数将权重归一化至一个概率分布
  - 最终权重与编码器的输出，结合得到最终的注意力

- 为何不省去编码器，把注意力机制直接作用于源序列？编码过程有重要的收益。

- 计算的复杂性：

- - 不含注意力的编码O(n)解码O(m)，整体时间复杂度是O(m+n)，
  - 含注意力，编码O(n)，解码每一步需要计算注意力O(n)，整体O(m*n)

- 可解释性：生成的注意力权重可以用来观察在产生当前输出时解码器认为源序列中哪些区域是相关的 。



17. 5 自然语言处理中基于注意力机制的模型

- 机器翻译     子词单元  融合单语数据   语言学标注
- 形态屈折 -- 输入基本词和期望的形态变化需求，输出该词的曲折形式
- 句法分析